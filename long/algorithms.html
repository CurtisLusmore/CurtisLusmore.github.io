<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Algorithms | lusmo.re</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/layout.css">
    <script src="/js/main.js" defer></script>
  </head>
  <body>
    <article>
      <header>
        <h1>Algorithms</h1>
      </header>
      <section>
        <p>
          In this guide, I present and discuss a number of common programming
          algorithms which are useful in a competitive programming environment.
          The format of the discussion for each algorithm looks something like
          this:
        </p>
        <ul>
          <li>
            Description: A description of the purpose of the algorithm, the
            problem it solves, the type of programming approach it uses, and
            its runtime complexity.
          </li>
          <li>
            The Gist: A brief explanation of the algorithm in plain English, to
            help in understanding how it works. With a better understanding,
            you will be able to better identify when the algorithm is
            appropriate, how to modify it to solve similar problems, and how to
            debug it if you encounter any problems.
          </li>
          <li>
            Pseudocode: A translation of the above explanation into a series of
            clear, unambiguous steps that each roughly correspond to a single
            task in program code. It should still read very much like plain
            English, and is intended to help understand how concepts are
            converted into a set of machine-readable instructions.
          </li>
          <li>
            Python Implementation: Finally, an implementation of the algorithm
            in Python. The code has been designed first and foremost to be easy
            to understand.
          </li>
        </ul>
        <p>
          The algorithms in this guide have been categorised by the types of
          problems they are most useful in solving. Within this guide, all
          algorithms will fall under one of the following categories: Dynamic
          programming, Graphs, Networks, Computational geometry, or Ad hoc and
          brute force (anything which doesn't fall under any of the previous
          categories).
        </p>
      </section>
      <header>
        <h1>Ad Hoc and Brute Force</h1>
      </header>
      <section>
        <p>
          Problems categorised as ad hoc (from Latin, lit. “for this”) or brute
          force are ones for which there is no specific class of algorithms
          suited to solving them. The algorithms discussed in this section are
          useful in many of these sorts of problems, but are also often useful
          in other problems as well. I have decided to start the guide with
          this section because the majority of these algorithms just require
          logical thinking and no specific theoretical knowledge.
        </p>
        <h2>Binary Search</h2>
        <h3>Description</h3>
        <p>
          There are many problems in which we have to find some optimal value
          that meets a given requirement. To state this more formally, the
          problem is to find the maximum value <math>x</math> for which some
          condition <math>P(x)</math> is satisfied. An example might be to find
          the best quality computer that meets a given budget, where the
          quality of a computer is equal to the quality of its worst part.
          Binary search is a divide and conquer technique which allows us to
          solve these sorts of problems for large search spaces very
          efficiently.
        </p>
        <p>
          A naïve approach would be to test all possible values, and return the
          largest value that was found to satisfy the condition. If there are a
          finite number of possible values, we can do this in linear time,
          which may or may not be fast enough depending on the size of the
          search space. If we are searching for an optimal floating point
          value, or even an integer in a large enough search space, this method
          is not efficient.
        </p>
        <p>
          However, if the problem displays the following two properties, we can
          use binary searching to find the optimal solution much faster, in
          logarithmic time:
        </p>
        <ol>
          <li>
            For all values of <math>x &gt; x'</math>, where <math>x'</math> is the
            optimal solution, <math>P(x)</math> is not satisfied, and
          </li>
          <li>
            For all values of <math>x &lt; x'</math>, <math>P(x)</math> is
            satisfied
          </li>
        </ol>
        <p>
          The first condition is true for all problems, since if we had a value
          <math>x &gt; x'</math> for which <math>P(x)</math> is satisfied, then
          <math>x</math> would be the optimal solution, not <math>x'</math>.
          The second is not always true, but we can usually reform the problem
          so that it will be. Using our first example from above, perhaps there
          is some quality level less than the optimal value for which we cannot
          build a computer within the budget (for example, if there are no
          parts with that particular quality level, and so no such computer
          exists). However, if we modify the problem slightly to say that a
          computer with quality level <math>x</math> also counts as a computer
          of all quality levels less than <math>x</math> as well, we are still
          trying to maximise the same value, but we can now build a computer
          within budget for all quality levels less than <math>x'</math> (using
          the computer of quality level <math>x'</math> itself if need be).
        </p>
      </section>
    </article>
    <nav>
      <ul>
        <li><a href="/">Home</a></li>
        <li><a href="/contact">Contact</a></li>
        <li><a href="/external">External</a></li>
        <li><a href="/posts">Posts</a></li>
        <li><a href="/projects">Projects</a></li>
        <li><a href="/subscribe">Subscribe</a></li>
        <li><a id="theme-switch" style="display: none;">Theme</a></li>
      </ul>
    </nav>
  </body>
</html>