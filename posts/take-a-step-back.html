<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta property="og:title" content="Take a Step Back">
    <meta property="og:image" content="https://lusmo.re/imgs/cover.jpg">
    <title>Take a Step Back | lusmo.re</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/layout.css">
    <script src="/js/main.js" defer></script>
  </head>
  <body>
    <article>
      <header>
        <h1>Take a Step Back</h1>
      </header>
      <section>
        <img class="author" src="/imgs/profile.png" title="Curtis Lusmore" alt="üë®">
        <p>
          Curtis Lusmore
          <br>
          <time datetime="2019-07-09">9 July 2019</time>
        </p>
      </section>
      <section>
        <p>
          In my time so far working in software development, as a developer and
          as a product manager, I‚Äôve made and seen a lot of mistakes. I spent
          some time recently reflecting on some of the biggest mistakes, the
          ones that ultimately cost the most time or money, that caused the
          most frustration and heartache, and tried to devise some lessons
          learnt. In the end I realised that the vast majority of mistakes were
          actually variants of the same core mistake, and that one main lesson
          applied to all of them.
        </p>
        <p>
          In this post I will discuss this mistake, some examples of where it
          comes up in software development, some thoughts on why it keeps
          happening, and some tips on how to avoid it.
        </p>
        <h2>The mistake</h2>
        <p>
          You‚Äôve probably seen a diagram like this before.
        </p>
        <img class="post" src="/imgs/posts/maxima.png" title="Maxima" alt="
      Global optimum -> /\
    Local optimum -> /\/  \
Current solution -> /      \
">
        <p>
          Think about this diagram in the context of solving a software
          development problem. You might know that your current solution isn‚Äôt
          optimal and so you look around you for the best solution.
          Unfortunately what you find isn‚Äôt the best possible solution, and in
          these circumstances it can be very difficult to even see the global
          optimum, let alone achieve it. But this isn‚Äôt the mistake I want to
          highlight. It‚Äôs not always enough to simply find the optimal solution
          and move towards it. It might be prohibitively expensive to reach the
          optimal solution from where we are, and the mistake is in trying to
          do this.
        </p>
        <p>
          The question isn‚Äôt ‚ÄúHow do we get from here to the optimal solution?‚Äù
          The question is ‚ÄúWhy did we start here in the first place?‚Äù
        </p>
        <p>
          Problems exist in layers. So often, the reason we are where we are
          today at this layer of the problem is because of a decision we made
          yesterday at a higher layer of the problem. The solution isn‚Äôt to
          work out how to navigate at this layer from where we are to where we
          want to be, but to take a step back and change the incorrect decision
          at the higher layer.
        </p>
        <p>
          Let‚Äôs look at this more concretely in the context of software
          development.
        </p>
        <h2>Layers of software development</h2>
        <p>
          The first layer of software development is the actual development,
          the programming. This is the land of implementation details, of
          off-by-one errors, of fragile legacy code. These are the problems
          that get in the way of what you really wanted to be doing. The
          problems you struggle to explain to your boss because they don‚Äôt
          understand your technical jargon. When deadlines approach, we get
          around these problems with ugly hacks that we promise we‚Äôll fix later
          but that we never get to, and the pile of tech debt grows bigger and
          bigger. When all else fails, we take the easy way out and implement
          what one of my colleagues lovingly calls ‚Äúdeveloper features‚Äù.
        </p>
        <p>
          The reason these problems are so hard to explain to our bosses is
          because nobody asked us to solve them. We made them up, they exist
          only in the minds of developers. In most cases, the specs don‚Äôt
          require us to solve these problems, and the solution isn‚Äôt to solve
          them but to work out how to avoid them entirely. This is commonly
          known as the <a href="https://en.wikipedia.org/wiki/XY_problem">XY
          problem</a>‚Äîwhen you face problem X, you come up with solution Y, you
          get stuck and you ask for help with Y instead of with X. It seems
          like a strange request but people offer some help, but nothing quite
          fits your problem. After much frustration and back-and-forth, they
          eventually discover that you really just need a better solution to X.
        </p>
        <p>
          Whenever you get stuck with a problem that nobody asked you to solve,
          take a step back and check the requirements to see if this is really
          a problem that needs solving at all, or if a different approach might
          help you avoid the problem entirely.
        </p>
        <p>
          Which leads in nicely to the next layer of software development: the
          requirements. This is the fuzzy grey area that sits between product
          owners and software developers. Typically when product owners think
          about people using their product, they imagine them being successful.
          They can paint a beautiful picture of how a feature will work when
          things go smoothly but they often gloss right over all those pesky
          details that developers need to implement a feature fully, when
          things go wrong or when users give unexpected input, and so the
          developers start making assumptions. This is the land of undefined
          behaviour, of unhelpful error messages and infinite loading screens,
          of inelegant failure modes.
        </p>
        <p>
          But in an attempt to avoid under-specifying a feature, you can go too
          far in the other direction and over-specify it. Sometimes it‚Äôs not
          until you try something out that you know what will work best from a
          technical perspective but also what will feel right from a user‚Äôs
          perspective, and the developer is always the first person to try a
          feature. Getting requirements right makes a huge difference to the
          usability of your software‚Äîit can be the difference between making a
          product that‚Äôs intuitive and a delight to use, or making one that‚Äôs
          jarring and frustrating for your users. Of course, ideally you would
          be iterating on these requirements anyway, but this is the first
          and cheapest opportunity to do so.
        </p>
        <p>
          When a requirement is starting to feel like more trouble than it‚Äôs
          worth, or you‚Äôre having to guess too much about how a feature should
          work, take a step back and consult with the product owner on what‚Äôs
          the best way to achieve the desired outcome for your users.
        </p>
        <p>
          The next layer of software development is the product itself. This is
          the layer where the value of the product ultimately lies. The product
          owner should define a vision for the product, the types of people who
          will use it, the problems it will solve, and the features it will
          need to solve them. They will also need focus, to determine the
          problems it won‚Äôt solve and the features it won‚Äôt have, because
          trying to be all things to all people makes a product incoherent,
          hard to use and hard to understand. And it‚Äôs a lot more expensive to
          build and maintain too.
        </p>
        <p>
          If you‚Äôre lucky, your users will have strong opinions about what
          features your product should have. Just remember that your users are
          also prone to XY problems, and rather than just building whatever
          they ask for, you should talk to them and try to discover their real
          problems. Some of the problems they describe will be valuable to
          solve with product features, some will be valuable but not well
          suited to your product and might make for a good separate product,
          some will be solveable with existing features in your product, and
          some will be low-value or one-off problems that aren‚Äôt worth building
          at all (although you can build a lot of good will by helping them
          solve these problems some other way).
        </p>
        <p>
          Whenever you are unsure about what features to include and how they
          should work, take a step back and think about the problem you are
          trying to solve for your users and how this feature will help.
        </p>
        <p>
          The next layer of software development is the go-to-market strategy.
          I wouldn‚Äôt be surprised if you groaned at the use of that phrase,
          because this is the first layer that starts to sound more business
          than fun which is exactly why it‚Äôs so commonly overlooked. This is
          the layer where your product actually starts to make a connection
          between your users and your wallet. If you are interested in getting
          your product in the hands of users, how do you describe it to them?
          What is the value proposition (ugh)‚Äîwhy should your users take time
          out of their busy lives to look at your product? What type of
          customer are you targeting? How valuable to them is a solution to the
          problem your product solves, and how much money do they have to spend
          on solving it? How are they solving this problem now, and how much
          money are they spending on it? Is it worth the same to all of your
          customers, or do you need a way to charge different amounts to
          different people? What else might they want from you besides the
          product itself, like training, consulting hours or support contracts?
        </p>
        <p>
          These are all hugely important questions to answer, and not just
          something you should consider after you‚Äôve built the product.
          Decisions at this layer will absolutely affect the requirements and
          priority of features. For example, if you are targeting only a small
          handful of large customers with a high-touch sales model, it might be
          cheaper to onboard your customers by hand rather than a building a
          fully-automated self-service registration page. If you need to
          describe your product in a particular way to get potential customers
          interested in it, you‚Äôd better make sure the features that support
          that description are prominent in the product, and that you don‚Äôt
          compromise on delivering them. If you‚Äôre trying to bring users over
          from one of your competitors, it might help to build a feature to
          help them import their existing data.
        </p>
        <p>
          When you‚Äôre considering what features your product needs, as well as
          the advice above you should also take a step back and think about
          what you‚Äôre actually selling to your customers, how they will get
          their hands on your product, and what features they will need to
          start getting value from it. Even for internal or line-of-business
          applications, you still have users and you still need to ‚Äúsell‚Äù to
          them if you want genuine adoption and a return on your investment.
        </p>
        <p>
          The last layer (that I will consider in this post) is the business.
          We all like to say that we do what we do to make a difference, but we
          still have a business to run. Just like our product can‚Äôt be all
          things to all people, neither can our business. A good business
          should also have a vision and focus, and it‚Äôs important that your
          product aligns to this vision if it‚Äôs going to be successful. There‚Äôs
          so much more to running a successful product than just building it. A
          great product can still be a failure in the wrong business, because
          it will struggle to get the resources and support that it needs to
          thrive.
        </p>
        <p>
          On the other hand, a product is just one way of achieving business
          needs. Some products exist soley for the purpose of generating demand
          for or increasing the retention of other products. If this is the
          case for your product, it‚Äôs important to be up-front and honest about
          this so that if circumstances change and you no longer have this need
          or you find a better way to satisfy it, you will know that it‚Äôs time
          to shift your focus to other things. It can be a tough call to make,
          but it‚Äôs far better than the alternative of soldiering on with a
          product that no longer serves a purpose for the business and watching
          it die a slow and painful death.
        </p>
        <p>
          When you‚Äôre thinking of building a new product, and periodically as
          you continue building existing products, it‚Äôs important to take a
          step back and remind yourself of how the product aligns to the vision
          and needs of your business, and whether this product is the best way
          to satisfy those needs.
        </p>
        <p>
          At every layer of software development, the biggest mistake that I
          see is not taking a step back.
        </p>
        <h2>Why does this mistake keep happening?</h2>
        <p>
          What causes these mistakes to reoccur so consistently, and across
          teams, companies, and industries? Here are some of the most common
          reasons that I see.
        </p>
        <p>
          Too busy. When deadlines are tight, you don‚Äôt always have time to
          stop and think about what you‚Äôre doing, and whether your approach is
          the best way to solve the problem. Often we don‚Äôt schedule time in
          our week for reflecting on what we‚Äôre doing, and as deadlines get
          closer these are usually the first things in our calendar to get cut.
        </p>
        <p>
          Too much free time. I know it seems like this contradicts my previous
          point, but <a href="https://en.wikipedia.org/wiki/Parkinson%27s_law"
          >Parkinson‚Äôs law</a> says that work expands to fill the time
          available, so when we are given too much time to work on something we
          are prone to overengineering our solutions and building things we
          don‚Äôt need.
        </p>
        <p>
          Following orders without questioning it. Just like lemmings
          cluelessly marching off a cliff without understanding what they‚Äôre
          doing, so too do we sometimes build what we‚Äôre told to build without
          questioning it. I‚Äôve noticed that this is especially true for
          decisions that were made before we joined the project‚Äîwe tend to
          assume that all decisions were made deliberately and for a good
          reason.
        </p>
        <p>
          Not my job. Similarly to above, even when we do question a decision
          we are often content to say that the decision is not our job to make
          so it won‚Äôt be our fault if it‚Äôs a bad decision. And while this may
          be true, it‚Äôs far from a productive attitude. Customers don‚Äôt care
          who‚Äôs responsible for making decisions, they just want the best
          possible product.
        </p>
        <p>
          The way we‚Äôve always done it. This is a layer above these last two
          points. Not only do we continue down the wrong path after a decision
          rather than fixing the mistake, we continue to make the same kinds of
          decisions when they come up again in the future, making the same
          kinds of mistakes over and over without learning from the past.
        </p>
        <p>
          The way industry leaders do it. Otherwise known as <a
          href="https://en.wikipedia.org/wiki/Cargo_cult">cargo culting</a>.
          The thinking here is that ‚Äúif it‚Äôs good enough for them, it‚Äôs good
          enough for us‚Äù, but many of the problems faced by industry leaders
          only come up at a big enough scale, and the solutions designed to
          solve these problems introduce problems of their own. If we aren‚Äôt at
          that scale, we don‚Äôt face those problems and we don‚Äôt need those
          solutions.
        </p>
        <p>
          No feedback loop. We can plan as well as we want, but without a
          feedback loop, when most things go off the rails they go off the
          rails hard. We like to think we have good intuition about what our
          users will want, we usually don‚Äôt. But even if we did, that wouldn‚Äôt
          mean that everything we build is done perfectly. Try navigating your
          house with your eyes closed and you‚Äôll realise quickly enough that
          even things you do literally every day can be impossible without a
          good feedback loop.
        </p>
        <p>
          Because it sounds like an interesting problem to solve. We all like
          to enjoy ourselves at work, and use exciting new tools. Sometimes we
          find problems or think of solutions that are so interesting we can‚Äôt
          help but try to solve them. This is also known as <a
          href="https://www.xkcd.com/356/">nerd sniping</a>. We‚Äôve all done
          this, and you can usually tell it‚Äôs a stupid idea but you get
          mesmerised by the cleverness of the solution.
        </p>
        <p>
          Because we‚Äôre too proud to admit mistakes. Nobody likes to admit that
          they‚Äôre wrong, and not only to other people. If after a year of
          building something you realise you‚Äôve been building the wrong thing,
          it can be incredibly hard to admit this to yourself. ‚ÄúHas this all
          been a complete waste of time?‚Äù It helps if you‚Äôre honest about this
          right from the start. Rather than setting yourself goals that depend
          on a sequence of unknowns turning out in your favour, make it your
          goal to understand the unknowns. If they go against you, you‚Äôve still
          succeeded and you won‚Äôt feel the need to continue wasting time on it.
        </p>
        <h2>
          Why does this matter?
        </h2>
        <p>
          There are plenty of people out there who are content with focusing on
          their own job and ignoring these mistakes when they see them in the
          work of others. ‚ÄúI did my part well, and I‚Äôm proud of the work that
          I‚Äôve done. It‚Äôs not my fault that the product failed/was a waste of
          time.‚Äù Personally, the way I see it is that it might not be my fault
          but it‚Äôs still my problem, because putting your heart and soul into
          something that doesn‚Äôt get used is painful. I don‚Äôt like building
          <a href="https://en.wiktionary.org/wiki/shelfware">shelfware</a>.
        </p>
        <p>
          Whether or not it‚Äôs in my job description, I will always push to
          improve decision making at all layers of software development, to
          give the product the best possible chance of being successful. Not
          by knowing the right decisions to make, because I certainly don‚Äôt.
          But by encouraging everybody to take a step back and assess decisions
          in the full and correct context.
        </p>
        <h2>
          What can we do about it?
        </h2>
        <p>
          Unsurprisingly, agile software development has many techniques for
          dealing with these problems, but it‚Äôs very important that you
          understand how these techniques are supposed to help. Writing your
          product ideas down on index cards and making a backlog isn‚Äôt
          intrinsically helpful, nor is breaking delivery up into arbitrary
          two-week intervals and calling them sprints. Getting a customer to
          pay you money as soon as possible is only helpful if you actually
          solicit and consider feedback from them. You can easily do all of
          these things without actually being agile‚Äîa practice that is often
          referred to as ‚ÄúAgile in name only‚Äù.
        </p>
        <p>
          To me, the important agile development techniques are those that
          force you to take a step back more often. Sprints are useful because
          at the start of a sprint you set a goal to be achieved in a fixed
          amount of time. Regardless of whether or not you achieve that goal,
          when the timebox runs out you take a step back and reflect on what
          you‚Äôre doing. Are we happy with our internal processes? Are there any
          improvements we can make as a development team? Is the product owner
          clear about the features and requirements? What do our customers
          think of what we‚Äôve built? Have we validated our assumptions? Should
          we persist with these decisions or try something else? Have our
          priorities changed? Are we getting enough value from our efforts or
          is it time to move on entirely?
        </p>
        <p>
          If you aren‚Äôt asking all these questions regularly you‚Äôre operating
          without a feedback loop and you‚Äôre probably already well off the
          rails. And if you haven‚Äôt scheduled time now to ask these questions,
          you‚Äôre only going to get busier and busier over time and get stuck in
          the ‚Äútoo busy to improve‚Äù loop we discussed earlier. It‚Äôs really
          important that you schedule time from the beginning for these
          reflective sessions and take a step back.
        </p>
      </section>
      <footer>
        <p>
          Thoughts? Comments?
          <a href="mailto:curtis@lusmo.re?subject=Take%20a%20Step%20Back">Email
          the author.</a>
        </p>
      </footer>
    </article>
    <nav>
      <ul>
        <li><a href="/">Home</a></li>
        <li><a href="/contact">Contact</a></li>
        <li><a href="/external">External</a></li>
        <li><a href="/posts">Posts</a></li>
        <li><a href="/projects">Projects</a></li>
        <li><a href="/subscribe">Subscribe</a></li>
      </ul>
    </nav>
  </body>
</html>