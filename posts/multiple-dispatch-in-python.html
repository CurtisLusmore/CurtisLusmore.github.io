<!DOCTYPE html>
<html lang="en-AU">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:title" content="Multiple Dispatch in Python">
  <meta property="og:image" content="https://lusmo.re/imgs/cover.jpg">
  <title>Multiple Dispatch in Python | lusmo.re</title>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/layout.css">
  <link rel="webmention" href="https://webmention.lusmo.re/post">
</head>

<body>
<header>
  <h1>Multiple Dispatch in Python</h1>
  <address>
    <img class="author" src="/imgs/author.png" title="Curtis Lusmore" alt="Photo of Curtis Lusmore">
    Curtis Lusmore, <time datetime="2015-07-25">25 July 2015</time>
  </address>
</header>
<main>
  <p>
    I recently read <a
    href="https://www.oreilly.com/programming/free/files/functional-programming-python.pdf"
    >Functional Programming in Python</a> which mentions a library which
    adds multiple dispatch to Python. One of my biggest hobbies is
    creating things from scratch, as it really helps me get a better
    understanding of how they work, so I thought I’d see if I couldn’t
    figure out how to do it myself.
  </p>
  <p>
    Here’s what I whipped up. I’ll add a disclaimer that in this form, it
    doesn’t work well for methods or class methods, as they both take a
    special argument in the first position (namely <code>self</code> or
    <code>cls</code>), and it doesn’t accept keyword arguments. At some
    stage I’ll try to make it a bit more rigorous.
  </p>
  <pre><code>class Dispatch:
    _existing = {}

    def __init__(self, *types):
        self.types = types

    def __call__(self, fn):
        name = fn.__qualname__
        if name not in self._existing:
            table = {}
            def dispatcher(*args):
                types = tuple(map(type, args))
                try:
                    overload = table[types]
                except KeyError:
                    try:
                        overload = table[(True,)]
                    except KeyError:
                        raise NotImplemented from None
                return overload(*args)
            self._existing[name] = (table, dispatcher)
        (table, dispatcher) = self._existing[name]
        table[self.types] = fn
        return dispatcher
</code></pre>
  <p>
    Once you tuck this away in a library somewhere where you don’t have
    to look at it, you can use it to write some pretty elegant code. See
    the following implementation of the flatten function.
  </p>
  <pre><code>@Dispatch(list)
def flatten(elems):
    return reduce(add, map(flatten, elems), [])

@Dispatch(True)
def flatten(elem):
    return [elem]
</code></pre>
</main>
<footer>
  <p>
    ← <a rel="next" href="/posts/pre-processing-imports-in-python">Pre-processing Imports in Python</a>
    <br />
    → <a rel="prev" href="/posts/programming-languages-for-beginners">Programming Languages for Beginners</a>
  </p>
</footer>
<nav>
  <menu>
    <li><a href="/">Home</a></li>
    <li><a href="/about">About</a></li>
    <li><a href="/external">External</a></li>
    <li><a href="/subscribe">Subscribe</a></li>
  </menu>
</nav>
</body>

</html>