<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
  <channel>
    <title>lusmo.re</title>
    <link>https://lusmo.re</link>
    <description>Curtis’ homepage</description>
    <item>
      <title>Multiple Git Profiles</title>
      <link>https://lusmo.re/posts/multiple-git-profiles</link>
      <guid>https://lusmo.re/posts/multiple-git-profiles</guid>
      <description>
        <p>
          If like me, you need to make Git commits from multiple email
          addresses on the same machine (say, from your personal and your work
          address), here’s a handy trick that will help make sure you make
          every commit with the right address.
        </p>
        <p>
          Start by creating a directory for each profile, named after the
          profile. In my case, I have <code>D:/git/home</code> and
          <code>D:/git/work</code>. Move all your Git repositories into
          the directory corresponding to the profile that you want to use when
          making commits to that repository. At the root of your profile
          directories, create a <code>.gitconfig</code> file with the following
          content.
        </p>
      </description>
      <pubDate>Thu, 31 January 2019 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Programming by Wishful Thinking</title>
      <link>https://lusmo.re/posts/programming-by-wishful-thinking</link>
      <guid>https://lusmo.re/posts/programming-by-wishful-thinking</guid>
      <description>
        <p>
          This is a technique that I discovered several years ago while
          teaching an introductory programming course, and I was extremely
          pleased to find out that although it had already been discovered, I
          had given it the same name. <a target="_blank"
          href="http://dsoguy.blogspot.com/2007/01/programming-by-wishful-thinking.html">
          Programming by wishful thinking</a> is a style of top-down
          program design that helps you improve the structure of your code,
          isolate the hairy parts from the simple parts, think more clearly
          about data flow, and work faster. I find it particularly helpful for
          novice programmers who feel intimidated when starting a new project
          and aren’t sure how to get started, but I still practise it regularly
          as well.
        </p>
      </description>
      <pubDate>Mon, 21 January 2019 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Diagnostics Anonymous</title>
      <link>https://lusmo.re/posts/diagnostics-anonymous</link>
      <guid>https://lusmo.re/posts/diagnostics-anonymous</guid>
      <description>
        <p>
          When working with large systems, especially with software, inevitably
          something will go wrong and you’ll be stuck trying to diagnose it.
          My years of developing software have given me a lot of practice
          diagnosing errors or unintended behaviour in software systems
          (usually in my own code), and over time I’ve built up a systematic
          process that I run through to speed up the process. In writing this
          post, I came to realise that my process actually has quite a lot in
          common with 12-step programs, so I’ve tweaked the format a little to
          make the content a little more interesting.
        </p>
      </description>
      <pubDate>Mon, 4 December 2017 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Imitating Classes</title>
      <link>https://lusmo.re/posts/imitating-classes</link>
      <guid>https://lusmo.re/posts/imitating-classes</guid>
      <description>
        <p>
          In this post, we are going to explore how you might imitate classes
          in a language that doesn’t have them, to get a better feel for how
          various object-oriented language features actually work. We will use
          JavaScript, but ban ourselves from using
        </p>
        <ul>
          <li>the class keyword (obviously),</li>
          <li>the new keyword (we will construct all of our own objects),</li>
          <li>the this keyword,</li>
          <li>prototypal inheritance (we will build our own inheritance
            mechanism).</li>
        </ul>
      </description>
      <pubDate>Mon, 13 November 2017 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>The Freedom of Restrictions</title>
      <link>https://lusmo.re/posts/the-freedom-of-restrictions</link>
      <guid>https://lusmo.re/posts/the-freedom-of-restrictions</guid>
      <description>
        <p>
          One of my great joys when designing things is when I discover that I
          can lift a restriction and make something both simpler and more
          powerful at the same time. This can happen at all levels, from
          something like changing a function signature to make it more generic,
          right up to unifying high level system components. The more generic
          something is, the more situations you can use it in, and the more
          value it can provide.
        </p>
      </description>
      <pubDate>Mon, 26 December 2016 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>What’s in a Language?</title>
      <link>https://lusmo.re/posts/whats-in-a-language</link>
      <guid>https://lusmo.re/posts/whats-in-a-language</guid>
      <description>
        <h2>What’s the purpose of a programming language?</h2>
        <p>
          A programming language is an interface between humans and computers,
          that allows us to program computers to perform some task. The purpose
          of the task is usually to solve some particular problem that the
          human has. Most languages are <a target="_blank"
          href="https://en.wikipedia.org/wiki/Turing_completeness">Turing
          complete</a>, which essentially means that they are mostly all
          equivalent. So what’s the point of creating a new programming
          language if it’s equivalent to ones that already exist? Turing
          completeness means that languages are equivalent in terms of the
          programs they are able to express, but it says nothing about the
          journey of getting to the finished program.
        </p>
      </description>
      <pubDate>Tue, 6 September 2016 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>What’s in a Language?</title>
      <link>https://lusmo.re/posts/whats-in-a-language</link>
      <guid>https://lusmo.re/posts/whats-in-a-language</guid>
      <description>
        <h2>What’s the purpose of a programming language?</h2>
        <p>
          A programming language is an interface between humans and computers,
          that allows us to program computers to perform some task. The purpose
          of the task is usually to solve some particular problem that the
          human has. Most languages are <a target="_blank"
          href="https://en.wikipedia.org/wiki/Turing_completeness">Turing
          complete</a>, which essentially means that they are mostly all
          equivalent. So what’s the point of creating a new programming
          language if it’s equivalent to ones that already exist? Turing
          completeness means that languages are equivalent in terms of the
          programs they are able to express, but it says nothing about the
          journey of getting to the finished program.
        </p>
      </description>
      <pubDate>Tue, 6 September 2016 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>199 Days of Git</title>
      <link>https://lusmo.re/posts/199-days-of-git</link>
      <guid>https://lusmo.re/posts/199-days-of-git</guid>
      <description>
        <h2>Reflections on Git streaking</h2>
        <p>
          May 20, 2016. My Git streak comes to an abrupt end on 199 days.
          Today, GitHub disabled the commit streak feature and left me stranded
          one day short of a milestone. It feels a little frustrating to get so
          close and then have it taken away, but in the end the overwhelming
          feeling is actually one of relief.
        </p>
        <p>
          I’m a chronic procrastinator and a prolific sidetracker—I’ve always
          had trouble following through on things after the initial whirl of
          enthusiastic development dies down. More often than not, it’s not so
          much that I get bored of the project I’m working, it’s that I get
          distracted by something else more exciting. I’ve tried lots of
          different approaches to improve this, but haven’t had much success.
        </p>
      </description>
      <pubDate>Fri, 20 May 2016 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Trust Nobody, Not Even Yourself</title>
      <link>https://lusmo.re/posts/trust-nobody-not-even-yourself</link>
      <guid>https://lusmo.re/posts/trust-nobody-not-even-yourself</guid>
      <description>
        <blockquote>
          <p>
            Trust the programmer
          </p>
        </blockquote>
        <p>
          This phrase is part of the C philosophy, and has influenced the
          design of many programming languages. In general C usage, this is
          best observed by the use of pointer casts—a mechanism by which the
          programmer can bypass the type system, trading compile-time type
          safety for flexibility and potentially incurring fatal crashes at
          run-time. The phrase needs little explanation—the programmer knows
          what they’re doing, don’t get in their way.
        </p>
      </description>
      <pubDate>Sat, 7 May 2016 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Why Static Isn’t Real Sharing</title>
      <link>https://lusmo.re/posts/why-static-isnt-real-sharing</link>
      <guid>https://lusmo.re/posts/why-static-isnt-real-sharing</guid>
      <description>
        <p>
          The static keyword has origins as far back as C, and has carried
          across to C++, Java and C#, among others—although its meaning has
          changed a bit along the way. In C# and Java, one of the common uses
          is for class-level sharing of members. Static members don’t belong to
          any instance, and can only be accessed directly from the class or
          from another definition in the same class.
        </p>
        <p>
          And this is all well and good for sharing within a class, but the
          problem is that it doesn’t play well with inheritance, because static
          members cannot be overridden. And inheritance is another common
          method of achieving code sharing. Consider the following snippet,
          which shows how one might hope to override static members in C#.
        </p>
      </description>
      <pubDate>Fri, 8 April 2016 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Intuition of Church Encoding</title>
      <link>https://lusmo.re/posts/intuition-of-church-encoding</link>
      <guid>https://lusmo.re/posts/intuition-of-church-encoding</guid>
      <description>
        <p>
          After first being introduced to the concept of Church numerals in
          <a target="_blank" href="https://mitpress.mit.edu/sicp/">Structure
          and Interpretation of Computer Programs</a>, I decided to learn more
          about them and the more general topic, <a target="_blank"
          href="https://en.wikipedia.org/wiki/Church_encoding">Church
          encoding</a>. For those who don’t know, Church encoding defines a way
          to represent common data types and structures in the
          <a target="_blank"
          href="https://en.wikipedia.org/wiki/Lambda_calculus">Lambda
          calculus</a> using only functions, since functions are the only terms
          available.
        </p>
        <p>
          I eventually stumbled upon a pretty neat intuition for how Church
          encodings work, which enables you to create encodings for arbitrary
          data types very easily. But first, a little on how I got there…
        </p>
      </description>
      <pubDate>Sat, 26 March 2016 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Programming Languages for Beginners</title>
      <link>https://lusmo.re/posts/programming-languages-for-beginners</link>
      <guid>https://lusmo.re/posts/programming-languages-for-beginners</guid>
      <description>
        <p>
          What’s the best/easiest programming language to learn for a beginner?
          I see this question asked all the time. Usually asked by people who
          want to get into programming, or maybe they’ve just finished learning
          the basics in their first language and are thinking about where to go
          next. It’s an innocent enough question and usually asked with good
          intentions, but it still bugs me every time I see it.
        </p>
      </description>
      <pubDate>Sat, 6 December 2014 00:00:00 GMT</pubDate>
    </item>
  </channel>
</rss> 